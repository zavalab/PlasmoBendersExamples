####################################################################
# This script contains some starter script for creating some of the visuals
# in the manuscript "Graph-Based Modeling and Decomposition of Hierarchical
# Optimization Problems" in case study 3. To build some of these visuals, we
# created the Plasmo OptiGraph and then export the graph structure of the
# projected OptiGraph. This script contains code for generating a set of CSVs
# for the Reliability Test System (RTS) with 73 buses. There is a CSV corresponding
# to the edge information and a CSV corresponding to the node information. We used
# the prgram Gephi (open source) for generating many of the graph visuals.

# To use Gephi, install it from their website and open the program. You can then
# navigate to "File > Import from Spreadsheet" and then choose the edge CSV
# generated by this file. We recommend importing it as an undirected graph. The
# user can then follow a similar process for the node CSV (making sure to choose
# append to existing spreadsheet when the option is shown). Gephi then provides
# different visualization options, including coloring nodes by data (e.g., node type)
# and determining node location using different algorithsm (we primarily used "Force
# Atlas 2". )

# In the script below, the RTS system is loaded and the graph is generated, where
# each bus/arc at each time point is represented by a node. The Graphs.jl SimpleGraph
# is then generated and the required CSVs are created.
####################################################################

####################################################################
# Load in RTS system
####################################################################
using Revise
using PowerSystems
using PowerSimulations
using Dates
using Logging
using DataFrames
using CSV
using StorageSystemsSimulations
using InfrastructureSystems
logger = configure_logging(console_level=Logging.Info)
const PSI = PowerSimulations
const PSY = PowerSystems
const SS = StorageSystemsSimulations
const IS = InfrastructureSystems
using TimeSeries
using JuMP
using HiGHS
using Gurobi
using Random

# Define seed (for adding noise to forecast horizons)
Random.seed!(10)

# Load in simulation functions for PSI
include((@__DIR__)*"/simulation_utils.jl")

# Set system location
sys_name = (@__DIR__)*"/../systems_data/RTS_system_PV_caseA.json"

# Set problem attributes
interval = 24 # simulation step interval in Hours
num_periods = 1
horizon = 24 * 15 # Simulation horizon in hours
steps = 1 # Number of steps in simulation
battery = true # Include LDES
form = "StorageDispatch" # Battery model to use
network_formulation = "StandardPTDFModel" # Network model to use
output_dir = (@__DIR__)*"/RTS_sims/Gurobi_15d" # Where to put the output directory

# Define solver to use
solver = optimizer_with_attributes(Gurobi.Optimizer, "MIPGap" => 3e-3)

# Build the output directory if it is not there
if !ispath(output_dir)
    mkpath(output_dir)
end

# Define the problem template
# used by PSI to define the optimization problem
template_uc = get_template_uc(network_formulation, "StorageDispatch")

# Load in the PSY system
sys_UC = System(sys_name)

# Set the units in PSY
set_units_base_system!(sys_UC, PSY.UnitSystem.SYSTEM_BASE)

# Add forecast errors for simulations
Random.seed!(10)
add_single_time_series_forecast_error!(sys_UC, horizon, Hour(interval), 0.05)

# Convert thermal Standard units with nuclear fuel to
# thermal multi-start; we fix these generators to be on later
convert_must_run_units!(sys_UC)

# Define models and simulations
models = SimulationModels(
    decision_models=[
        DecisionModel(template_uc,
            sys_UC,
            name="UC",
            optimizer=solver,
            initialize_model=false,
            optimizer_solve_log_print=true,
            direct_mode_optimizer=true,
            check_numerical_bounds=false,
            warm_start=true,
        ),
    ],
)

# Define the simulation sequence (for PSI)
sequence = SimulationSequence(
    models=models,
    ini_cond_chronology=InterProblemChronology(),
)

# Build the simulation in PSI
# This will build the JuMP model
sim = Simulation(
    name="test",
    steps=steps,
    models=models,
    sequence=sequence,
    simulation_folder=output_dir,
)
build!(sim, console_level=Logging.Info, file_level=Logging.Info)

# Get the model object from the simulation object
model = get_simulation_model(sim, :UC)

# Get the constraints from the model and their keys
cons = model.internal.container.constraints
con_keys = collect(keys(cons))

# Get the variables from the model and their keys
vars = model.internal.container.variables
var_keys = collect(keys(vars))

# Get the set of thermal standard devices that use nuclear fuel
ts_devices = collect(get_components(ThermalStandard, sys_UC))
nuclear_devices = [i for i in ts_devices if i.fuel == PSY.ThermalFuels.NUCLEAR]

# Get the list of on variables from the model
on_vars = vars[PSI.VariableKey{OnVariable, ThermalStandard}("")]

# get the names of the nuclear devices, and fix the on variables to be 1
# this code only matters if you do not call `convert_must_run_units!`
nuclear_names = [i.name for i in nuclear_devices]
for j in nuclear_names
    for k in on_vars.axes[2]
        var_to_fix = on_vars[j, k]
        fix(var_to_fix, 1, force = true)
    end
end

# Get the on variables for the multi-start generators (which are the ones)
# converted from ThermalStandard to ThermalMultiStart for the RTS
vars = model.internal.container.variables
on_vars = vars[PSI.VariableKey{OnVariable, ThermalMultiStart}("")]

# Fix these generators to be on
for i in on_vars.data[:]
    JuMP.fix(i, 1, force = true)
end

# Get the JuMP model from the PSI Model
jm = model.internal.container.JuMPmodel

####################################################################
# Build Plasmo OptiGraph
####################################################################

# Load in the PSI to Plasmo file
include((@__DIR__)*"/PSI_to_Plasmo_high_res.jl")

# Build the OptiGraph from the model
time_to_build_plasmo = @elapsed graph, var_to_var, bus_names, arc_names = build_graph_from_model(model, sys_UC, horizon)

println("Time to build model was ", time_to_build_plasmo / 60, " minutes")

# Get the projection of the OptiGraph
cg = Plasmo.clique_projection(graph)

# get the Graphs.jl SimpleGraph
g = cg.projected_graph

####################################################################
# Build the CSVs for the full 15 day problem, then the 1 day problem
# and then the system structure (not the OptiGraph)
####################################################################

# Load in the required packages
using Graphs, SparseArrays

# Define a function that will create the DataFrame of edge connections
# from the SimpleGraph; To our knowledge, Gephi expects the CSV to have
# the form "Source" and "Target" as the column names
function get_edge_list(g)
    am = Graphs.adjacency_matrix(g)
    I_g, J_g, z_g = findnz(am)
    edge_list = Matrix{Int}(zeros(length(I_g), 2))
    for i in 1:length(I_g)
        if J_g[i] <= I_g[i]
            edge_list[i, :] .= [J_g[i], I_g[i]]
        end
    end
    edge_list = edge_list[(edge_list[:, 1] .!= 0), :]
    df = DataFrame(["Source" => edge_list[:, 1], "Target" => edge_list[:, 2]])
    return df
end

# Create the edge DataFrame
df_edges = get_edge_list(g)

# Load in system information
buses = collect(get_components(Bus, sys_UC))
bus_names = [i.name for i in buses]
arcs = collect(get_components(Arc, sys_UC))
lines = collect(get_components(Line, sys_UC))
tts   = collect(get_components(TapTransformer, sys_UC))

# There is one arc that is not actually used; remove this arc
used_arcs = []
for i in 1:length(lines)
    push!(used_arcs, lines[i].arc)
end
for i in 1:length(tts)
    push!(used_arcs, tts[i].arc)
end
used_arcs = unique(used_arcs)

# Create a vector of the node ids; these are the integer values of the
# source/target columns of the edge DataFrame
node_id = [i for i in 1:length(all_nodes(graph))]

# Assign each node to a single time point
node_time = zeros(Int, length(node_id))
# Assign each node to be either a bus or an arc
node_type = String[]

# The bus nodes were added first, so we will first loop through the buses and then the arcs
for i in 1:horizon
    for j in 1:length(bus_names)
        index = j + (i - 1) * (length(bus_names))
        node_time[index] = i
        push!(node_type, "Bus")
    end
end

for i in 1:horizon
    for j in 1:length(arc_names)
        index = (length(bus_names) * horizon) + j + (i - 1) * (length(arc_names))
        node_time[index] = i
        push!(node_type, "Arc")
    end
end

# Create vectors assigning each node to a time period (day, 2 days, or 3 days)
node_time_part_1 = ceil.(node_time ./ 24)
node_time_part_2 = ceil.(node_time ./ 48)
node_time_part_3 = ceil.(node_time ./ 72)

# Create the dataframe for exporting to a CSV
df_nodes = DataFrame([
    "id" => node_id,
    "TimePoint" => node_time,
    "TimeAgg" => node_time_part_1,
    "Time_agg2" => node_time_part_2,
    "Time_agg3" => node_time_part_3,
    "Type" => node_type,
])

# Uncomment these lines to export to a CSV
#CSV.write((@__DIR__)*"/node_data_RTS.csv", df_nodes)
#CSV.write((@__DIR__)*"/edge_data_RTS.csv", df_edges)

# Next, we will create the data for a single time point of the graph
# the easiest way to do this is to just partition the graph into subgraphs, the
# first having the first time point and the second having all other time poitns

# Create a partitioning vector
part_vector = fill(2, Plasmo.num_nodes(graph))

# Set the first 181 nodes to be the first partition. There are 73 bus nodes + 108 arc nodes
part_vector[1:181] .= 1

# Create the partition
partition = Partition(graph, part_vector)

# Apply the partition to the optigraph
apply_partition!(graph, partition)

# Get the first subgraph
graph_t1 = getsubgraphs(graph)[1]

# Get the projected graph
cg_t1 = Plasmo.clique_projection(graph_t1)

# Get the SimpleGraph
g_t1 = cg_t1.projected_graph

# Define the edge data for the CSV
df_edges_t1 = get_edge_list(g_t1)

# Define a node ID vector and a type vector
node_id = [i for i in 1:Plasmo.num_nodes(graph_t1)]
node_type = ["Bus" for i in 1:Plasmo.num_nodes(graph_t1)]
node_type[74:end] .= "Arc"

# Create the node DataFrame
df_nodes_t1 = DataFrame([
    "id" => node_id,
    "Type" => node_type
])

# Uncomment these lines to export the data
#CSV.write((@__DIR__)*"/edge_data_RTS1.csv", df_edges_t1)
#CSV.write((@__DIR__)*"/node_data_RTS1.csv", df_nodes_t1)

# The last visualization is for the network itself, not the OptiGraph
# There is no node data for this, but we will create the edge data by building a SimpleGraph
# with nodes for each bus and then placing an edge for every arc

# Map bus names to their number
bus_dict = Dict(bus.name => i for (i, bus) in enumerate(buses))

# Define the SimpleGraph
g_sys = SimpleGraph(length(buses))

# Loop through the used arcs and add an edge for each bus
for arc in used_arcs
    add_edge!(g_sys, bus_dict[arc.from.name], bus_dict[arc.to.name])
end

# Define the edge data
df_edges_sys = get_edge_list(g_sys)

# Uncomment this line to export the edge data
#CSV.write((@__DIR__)*"/edge_data_RTS_sys.csv", df_edges_sys)
